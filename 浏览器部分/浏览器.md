# 浏览器

## 浏览器是多进程的

作为前端, 免不了和浏览器打交道, 浏览器是多进程的, 拿 Chrome 来说, 我们每打开一个 Tab 页就会产生一个进程, 我们使用 Chrome 打开很多标签页不关, 电脑会越来越卡, 不说其他, 首先就很耗 CPU

## 浏览器包含哪些进程

### Browser 进程

- 浏览器的主进程(负责协调, 主控), 该进程只有一个
- 负责浏览器界面的显示, 与用户交互, 如前进, 后退等
- 负责各个页面的管理, 创建和销毁其他进程
- 将渲染(Renderer)进程得到的内存中的 Bitmap(位图), 绘制到用户界面上
- 网络资源的管理, 下载等

### 第三方插件进程

- 每种类型的插件对应一个进程, 当使用该插件时才创建

### GPU 进程

- 该进程也只有一个, 用户 3D 绘制等等

### 渲染进程(重)

- 即通常所说的浏览器内核(Renderer 进程, 内部是多线程)
- 每个 Tab 页面都有一个渲染进程, 互不影响
- 主要作用为页面渲染, 脚本执行, 事件处理等

在 Renderer 进程中, 为了不让其他操作阻止渲染线程的高速执行, 我们通常会将渲染过程`管线化`, 即多个 Renderer 进程取抢占 CPU 的资源

## 为什么浏览器要多进程

- 我们假设浏览器是单进程, 那么某个 Tab 也崩溃了, 就影响了整个浏览器, 体验有多差

- 同理如果插件崩溃了也会影响整个浏览器

- 当然多进程还有其他的诸多优势, 不过多阐述

- 浏览器进程有很多, 每个进程又有很多线程, 都会占用内存

- 这也意味着内存等资源消耗会很大, 有点拿空间换时间的意思

## 简述渲染进程 Renderer(重)

页面的渲染, JS 的执行, 事件的循环, 都在渲染进程内执行, 所以我们要重点了解渲染进程

渲染进程是多线程的, 我们来看渲染进程的一些常用较为主要的线程

### 渲染进程 Renderer 的主要线程

1. GUI 渲染线程

   1. 负责渲染浏览器界面, 解析 HTML, CSS, 构建 DOM 树和 RenderObject 树, 布局和绘制等
      1. 解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点, 生成 DOM 树, 也就是 DOM Tree
      2. 解析 css, 生成 CSSOM(CSS Object Model)
      3. 把 DOM Tree 和 CSSOM 结合, 生成 Rendering Tree(渲染树)
      4. 通过 Render Tree 计算出布局 Layout Tree
      5. 渲染引擎遍历 Render Tree, 绘制(painting) 到界面上
   2. 当我们修改了一些元素的颜色或者背景色, 页面就会重绘(Repaint)
   3. 当我们修改元素的尺寸, 页面就会回流(Reflow)
   4. 当页面需要 Repaing 和 Reflow 时 GUI 线程执行, 绘制页面
   5. 回流(Reflow)比重绘(Repaint)的成本要高, 我们要尽量避免 Reflow 和 Repaint
   6. GUI 渲染线程与 JS 引擎线程是互斥的
      1. 当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)
      2. GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行
      3. GUI 渲染线程和 JS 引擎线程互斥: 因为 js 时可以操作 DOM 的，如果在修改这些元素属性的时候同时渲染页面，那渲染前后获得的元素数据可能会不一致。所以为防止渲染出现不可预期的结果，浏览器设置了二者是互斥的

2. JS 引擎线程

   1. JS 引擎线程就是 JS 内核, 负责处理 Javascript 脚本程序(例如 V8 引擎)
   2. JS 引擎线程负责解析 Javascript 脚本, 运行代码
   3. JS 引擎一直等待着任务队列中任务的到来, 然后加以处理
      1. **浏览器同时只能有一个 JS 引擎线程在运行 JS 程序, 所以 js 是单线程运行的**
      2. 一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序
   4. GUI 渲染线程与 JS 引擎线程是互斥的, JS 引擎线程会阻塞 GUI 渲染线程
      1. 就是我们常遇到的 JS 执行时间过长, 造成页面的渲染不连贯, 导致页面渲染加载阻塞(就是加载慢)
      2. 例如浏览器渲染的时候遇到`<script>`标签, 就会停止 GUI 的渲染, 然后 js 引擎线程开始工作, 执行里面的 js 代码, 等 js 执行完毕, js 引擎线程停止工作, GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况

3. 事件触发线程

   1. 属于浏览器而不是 JS 引擎, 用来控制事件循环, 并且管理着一个事件队列(task queue)
   2. 当 js 执行碰到事件绑定和一些异步操作(如 setTimeout, 也可来自浏览器内核的其他线程, 如鼠标点击、AJAX 异步请求等), 会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作, 便把定时器事件添加到定时器线程), 等异步事件有了结果, 便把他们的回调操作添加到事件队列, 等待 js 引擎线程空闲时来处理。
   3. 当对应的事件符合触发条件被触发时, 该线程会把事件添加到待处理队列的队尾, 等待 JS 引擎的处理
   4. 因为 JS 是单线程, 所以这些待处理队列中的事件都得排队等待 JS 引擎处理

4. 定时触发器线程

   1. setInterval 与 setTimeout 所在线程
   2. 浏览器定时计数器并不是由 JavaScript 引擎计数的(因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确)
   3. 通过单独线程来计时并触发定时(计时完毕后, 添加到事件触发线程的事件队列中, 等待 JS 引擎空闲后执行), 这个线程就是定时触发器线程, 也叫定时器线程
   4. W3C 在 HTML 标准中规定, 规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms

5. 异步 http 请求线程

   1. 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
   2. 将检测到状态变更时, 如果设置有回调函数, 异步线程就产生状态变更事件, 将这个回调再放入事件队列中再由 JavaScript 引擎执行
   3. 简单说就是当执行到一个 http 异步请求时, 就把异步请求事件添加到异步请求线程, 等收到响应(准确来说应该是 http 状态变化), 再把回调函数添加到事件队列, 等待 js 引擎线程来执行
