# 进程与线程

## 前言

在说进程与线程之前, 先来了解一些和操作系统相关的东西, 我觉得会对你有帮助的, 如果这些东西你都知道, 直接忽略他们去看正文即可

> 处理器

计算机的 "大脑" 是 CPU, 他从内存中取出指令并执行, 在每个 CPU 基本周期中, 首先从内存中取出指令, 解码以确定其类型和操作数, 接着执行, 然后取值, 解码并执行下一条指令, 按照这一方式, 程序被执行完成

每个 CPU 都有一套可执行的专门指令集, 所以, x86 处理器不能执行 ARM 程序, 而 ARM 处理器也不能执行 x86 程序, **由于用来访问内存以得到指令或数据的时间比执行指令花费的时间长得多, 因此, 所有 CPU 内部都有一些用来保存关键变量和临时数据的寄存器, 这样, 通常在指令集中提供一些指令, 用以将一个字从内存调入寄存器, 或者用两者产生一个结果, 如将两个字相加并把结果存在寄存器或内存中**

除了用来保存变量和临时结果的通用寄存器之外, 多数计算机还有一些对程序员可见的专用寄存器, 其中之一就是`程序计数器`, **他保存了将要取出的下一条指令的内存地址, 在指令取出之后, 程序计数器就被更新以便指向后继的指令**

另一个寄存器就是`堆栈指针`, **他指向内存中当前栈的顶端, 该栈包含了每个执行过程的栈帧. 一个过程的栈帧中保存了有关的输入参数, 局部变量以及那些没有保存在寄存器中的临时变量**

操作系统必须知晓所有的寄存器, 在时间多路复用 CPU 中, 操作系统经常会中止正在运行的某个程序并启动(或再启动)另一个程序, **每次停止一个运行着的程序时, 操作系统必须保存所有的寄存器值, 这样在稍后该程序再次启动时, 可以把这些寄存器重新装入**

> 多道程序设计

多道程序设计是在计算机内存中同时存放几道相互独立的程序, 使他们在管理程序控制之下, 相互穿插的运行. 两个或两个以上程序在计算机系统中同时处于开始到结束之间的状态

多道程序技术运行的特征有: `多道`, `宏观上并行`, `微观上串行`

> 程序

程序是指系统指令和数据的有序集合, 是一个静态的实体, 不存在运行状态的概念
进程使程序运行所处的状态实体名称, 是一个动态概念
进程包含程序, 进程的执行离不开程序

了解了一些相关的知识点后, 下面进入正文:

## 1.进程

> 进程由操作系统调度
> 进程是资源分配的基本单位
> 一个进程就是一个正在执行程序的实例, 包括程序计数器, 寄存器和变量的当前值
> 每个进程至少有一个主执行线程, 他无需用户主动创建, 一般由系统自动创建, 主执行线程终止了, 进程也随之终止
> 当一个进程关闭之后, 操作系统会回收进程所占用的内存

在任何多道程序设计系统中, CPU 由一个进程快速切换到另一个进程, 使每个进程各运行几十或几百毫秒, 严格地说, 在某一个瞬间, CPU 只能运行一个进程, 但在 1s 内, 他可能运行多个进程, 这样就产生并行的错觉. 有时人们所说的`伪并行`就是指这种情形, 以此来区分`多处理器系统(该系统有两个或多个 CPU 共享同一个物理内存)`的真正硬件并行

一个进程是某种类型的一个活动, 他有程序, 输入, 输出以及状态, 单个处理器可以被若干进程共享, 他使用某个调度算法决定何时停止一个进程的工作, 并转而为另一个进程提供服务

### 1.1.进程的三种状态

在第 4 版的 <<现代操作系统>> 一书中, 将进程分为三种状态, 但其他地方对于进程的状态分为了五种: 创建, 就绪, 阻塞, 运行, 终止, 但核心都在中间三种状态之间, 所以这里主要谈进程的 `运行态`, `就绪态`, `阻塞态`

进程的三种状态分别为:

- 运行态: 该时刻进程实际占用 CPU
- 就绪态: 可运行, 但有其他进程正在运行而暂时停止
- 阻塞态: 除非某种外部事件发生, 否则进程不能运行

前两种状态在逻辑上是类似的, 处于这两种状态的进程都可以运行, 只是对于第二种状态暂时没有 CPU 分配给他, 第三种状态与前两种状态不同, 处于该状态的进程不能运行, 即使 CPU 空闲也不行

![Snipaste_2020-09-06_13-18-09](https://user-images.githubusercontent.com/45334593/95016476-c9bdac80-0685-11eb-8f7a-e69ee3c5665e.png)

- **这里要注意的是, 转换 2 和转换 3 是由进程调度程序引起的, 进程调度程序是操作系统的一部分, 进程甚至感觉不到调度程序的存在. 系统认为一个运行进程占用处理器的时间已经过长, 决定让其他进程使用 CPU 时间时, 会发生转换 2. 在系统已经让所有其他进程享有了他们应有的公平待遇而重新轮到第一个进程再次占用 CPU 运行时, 会发生转换 3**
- **当进程等待的一个外部事件发生时(如一些输入到达), 则发生转换 4, 如果此时没有其他进程运行, 则立即发生转换 3**

### 1.2.进程控制块(Process Control Block)

为了实现进程模型, 操作系统维护着一张表格(一个结构数组), 即`进程表`(process table). 每个进程占用一个进程表项, 即通常所说的`进程控制块`, 该表项包含了进程状态的重要信息, 包括`程序计数器`, `堆栈指针`, `内存分配状况`, `所打开文件的状态`, `账号和调度信息`, 以及其他在进程中由运行态转换到就绪态或阻塞态必须保存的信息, 从而保证该进程随后能再次启动, 就像从未中断过一样
**所有的中断都从保存寄存器开始**, 对于当前进程而言, 通常是保存在进程表项中, 随后, 会从堆栈中删除由中断硬件机制存入堆栈的那部分信息, 并将堆栈指针指向一个由进程处理程序所使用的临时堆栈

> 所谓的创建进程和撤销进程, 都是指对 PCB 的操作
> 对于单进程来说, 页面的内存泄漏也是单进程变慢的一个重要原因, 通常浏览器的内核都是十分复杂的, 运行一个复杂点的页面再将其关闭之后, 会存在内存泄漏, 即内存不能回收完全的情况, 这就导致使用时间越长, 内存占用越高, 浏览器就会变得越慢

### 1.3.多进程

多进程是指在同一时间里, 同一个计算机系统中如果运行两个或两个以上的进程处于运行状态, 现代的操作系统几乎都是多进程操作系统, 能够同时管理多个进程的运行

多进程优点:

1. 每个进程相互独立, 此进程崩溃不会影响主程序的稳定性
2. 通过增加 CPU, 就可以很容易地扩充性能
3. 进程能直接获取系统的资源, 总体能够达到的性能上限非常大

### 1.4.浏览器多进程

![img](https://user-gold-cdn.xitu.io/2020/6/17/172c2c84be474219?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

从图中可以看出, Chrome 的页面是运行在单独的渲染进程中的, 同时页面里的插件也是运行在单独的插件进程之中, 而进程之间是通过 IPC 机制进行通信(如图中虚线部分)

- 进程使相互隔离的, 所以一个页面或者插件崩溃后, 影响到的仅仅是当前的页面进程或者插件进程, 并不会影响到浏览器和其他页面
- JavaScript 也是运行在渲染进程中的, 所以即使 JavaScript 阻塞了渲染进程, 影响到的也只是当前的渲染页面, 而并不会影响浏览器和其他页面, 因为其他页面的脚本是运行在它们自己的渲染进程中的
- 沙箱模式解决安全问题`安全沙箱`, 你可以把沙箱看成是操作系统给进程上了一把锁, 沙箱里面的程序可以运行, 但是不能在你的硬盘上写入任何数据, 也不能在敏感位置读取任何数据, 例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面, 这样即使在渲染进程或者插件进程里面执行了恶意程序, 恶意程序也无法突破沙箱去获取系统权限

## 2.线程

> 线程是资源调度的基本单位
> 线程由 CPU 调度

- **进程是资源分配的基本单位, 但是线程不拥有资源, 同一进程中的线程共享进程中的资源**

在传统操作系统中, 每个进程有一个地址空间和一个控制线程. 事实上, 这几乎就是进程的定义, 不过, 经常存在在同一个地址空间中准并行运行多个控制线程的情形, 这些线程就像(差不多)分离的进程(共享地址空间除外)

在许多应用中同时发生着多种活动, 其中某些活动随着时间的推移会被阻塞, 通过将这些应用程序分解成可以准并行运行的多个顺序线程, 程序设计模型会变得更简单

- **由于线程比进程更轻量级, 所以他们比进程更容易(即更快)创建, 也更容易撤销. 在许多系统中, 创建一个线程较创建一个进程快 10~100 倍**

线程是建立在进程基础上的一次程序运行单位, 通俗点解释就是线程就是程序中的一个执行流, 线程是不能单独存在的, 它是由进程来启动和管理的, 一个进程可以有一个或多个线程, **当一个进程拥有多个线程时, 每个线程都有一套独立的寄存器和堆栈指针, 而代码, 数据和文件是共享的**

### 2.1.多线程

一个进程中只有一个执行流称作单线程, 即程序执行时, 所走的程序路径按照顺序执行

线程依附于进程, 而进程中使用多线程并行处理能提升运算效率

**利用多个线程编程的概念就叫做多线程处理, 多线程是为了同步完成多项任务, 不是为了提高运行效率, 而是为了提高资源使用率来提高系统的效率**

**进程将 CPU 资源分配给线程, 即真正在 CPU 上运行的是线程, 进程本身不会负责调度线程, 进程和线程都是 OS 调度的(即操作系统调度, Operating System)**

**线程在应用层实现有一个优点就是线程切换不用内核介入, 所以线程的切换回非常地快, 也就是说线程的调度策略是自己实现的**

**由于内核只知道进程而不知道线程, 那么进程中的任何一个线程被阻塞, 导致进程中的其他线程也被阻塞**

#### 2.1.1.多线程缺点

1. 多线程比多进程成本低, 但是性能也更低
2. 一个线程的崩溃可能影响到整个程序的稳定性
3. 线程多了以后, 线程本身的调度也很麻烦, 需要消耗较多的 CPU
4. 无法直接获取系统的资源, 总体能够达到的性能上限有限制
5. 线程之间的同步和加锁比较麻烦

### 2.2.同一进程的线程共享哪些资源

1. 堆: 由于堆是在进程空间中开辟出来的, 所以他是理所当然的被共享的, 因此 new 出来的都是共享的(16 位平台上分全局堆和局部堆, 局部堆是独享的)
2. 全局变量: 他是与具体某一函数无关的, 所以也与特性线程无关, 因此也是共享的
3. 局部静态变量: 虽然对于局部变量来说, 他在代码中是 "放" 在某一函数中的, 但是其存放位置和全局变量一样, 存于堆中开辟的 .bss 和 .data 段, 是共享的
4. 文件等公用资源: 这个是共享的, 使用这些公共资源的线程必须同步

### 2.3.线程独享的资源

- 栈
- 寄存器
- 线程 ID

### 2.4.引入线程的好处

1. 线程占用资源要比进程少得多
2. 创建一个新的线程花费的代价小
3. 切换线程方便
4. 提高并发性

## 拓展

1. 内核实现线程和用户空间一一对应, 可以有效的解决方案一中的缺点, 但是由于在内核中实现用户空间相同数量的线程数, 开销比较大

2. 用户空间中多个线程映射到内核中的一个线程, 这样一来, 内核中的线程就不用创建那么多, 而且阻塞的概率也降低了, 这是一种平衡和折中的方式。JVM 就是实现了这种方式。JVM 本身就是一个进程, JVM 可以创建很多线程, 然后对应内核中的线程, 内核中的线程调度 CPU

3. 多核 CPU 和多个 CPU 有何区别? 参见[这篇文章](https://www.zhihu.com/question/20998226)中的第一个回答, 如下图:
   ![image-20201004210217854](https://user-images.githubusercontent.com/45334593/95016541-2c16ad00-0686-11eb-974e-89cd56c2d85f.png)
