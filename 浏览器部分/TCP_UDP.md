# TCP_UDP

## TCP(打电话)

TCP: Transmission Control Protocol 传输控制协议

- 特点: 面向连接(收发数据前, 必须建立可靠的连接)
- 建立连接基础: 三次握手
- 应用场景: (数据必须准确无误的收发)

  - HTTP 请求
  - FTP 文件传输
  - 邮件收发
- 优点:

  - 稳定
  - 重传机制: 有一个检测机制, 发现某个地方传输有问题, 会进行重传
  - 拥塞控制机制: TCP 连接中, 可能会有一些信息传输过程中拥挤的状态,这种状态他会进行控制
  - 断开连接: 实时的断开连接
- 缺点:

  - 速度慢: 因为要建立可靠的连接, 这就需要花时间
  - 效率低: 因为要保持稳定, 所以他的速度不能快
  - 占用资源: TCP 占用很高
  - 容易被攻击: 三次握手 -> DOS, DDOS 攻击
- TCP/IP 协议组: 提供点对点的连接机制, 制定了数据封装, 定址, 传输, 路由, 数据接收的标准

## UDP(喇叭叫人)

UDP: User Data Protocol 用户数据包协议

**我叫你, 你不用什么东西就能听得到, 不想听都听得到**

- 特点: 面向无连接(不可靠的协议, 无状态的传输机制)
- 无连接信息发送机制
- 应用场景:
  - 无需确保通讯质量
  - 要求速度快
  - 无需确保信息完成
  - 消息收发, 语音通话, 直播, QQ(像 QQ, 游戏 这种既有 TCP, 又有 UDP)
- 优点:
  - 安全
  - 快速
  - 漏洞少(被利用的机会少)(UDP flood 攻击)
- 缺点:
  - 不可靠
  - 不稳定
  - 容易丢包
- 总结: 只要目的源地址, 端口号, 地址确定, 则可以直接发送信息报文, 但不能保证一定能收到或者收到完成的数据

## 建立 TCP 连接的前奏

- 标志位: 数据包
- SYN: Synchronize Sequence Number 同步序列编号
- ACK: Acknowledgemenu 确认字符
- 状态:
  - LISTEN: 侦听 TCP 端口的连接字符(我等着你发送连接请求呢)
  - SYN_SEND: 在发送连接请求后等待匹配的连接请求(我发送了连接请求, 我等你回复哈)
  - SYN_RECEIVED: 在收到和发送一个连接请求后等待连接请求的确认(我收到了你的连接请求了哈, 我等你回复我)
  - ESTABLISHED: 代表一个打开的连接, 数据可以发送给用户(建立了哈, 我根你说一下)

## 三次握手(Three-way Handshake)

### 概念

**三次握手(Three-way Handshake) 其实就是建立指建立一个 TCP 连接时, 需要客户端总共发送三个包**

**进行三次握手的作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备**

**实质其实就是指定服务器端口， 建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息**

**刚开始，客户端处于 Closed 状态，服务器处于 Listen 状态**

### 建立三次握手

- 第一次握手: 客户端向服务器发送 SYN 标志位, 并指明客户端的初始化序列号 ISN(Initial Sequence Number), 此时客户端处于 SYN_SEND 状态
  - 首部的 SYN=1，初始序号 sep=x，SYN 的报文段不能携带数据，但要消耗掉一个序号
- 第二次握手: 服务器收到客户端的 SYN 报文之后，会以自己的 SYN 作为应答，并且也是指定了自己的初始序列号 ISN(s)，同时会把客户端的的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RECEIVED 状态
  - 在确认报文中，SYN=1，ACK=1，ack=x+1，初始序号 sep=y
- 第三次握手: 客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN+1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态，服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已经建立起了 TCP 连接
  - 确认报文 ACK=1，ack=y+1，序号为 x+1(初始为 seq=x, 所以第二个报文段要+1)

**ACK报文段可以携带数据**，不携带数据则不消耗序号

先发送第一个 SYN 的一端执行主动打开(active open)，接收这个 SYN 并发回下一个 SYN 的一端执行被动打开(passive open)

![img](https://pic3.zhimg.com/80/v2-2a54823bd63e16674874aa46a67c6c72_720w.jpg)

#### 为什么需要三次握手，两次不行吗?

弄清这个问题，我们需要先明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的

#### 三次握手的目的

- 第一次握手：客户端发送网络包， 服务器收到了
  - 这样服务端就能得出结论：客户端的发送能力，服务端的接收能力是正常的
- 第二次握手：服务端发送包，客户端接收到了
  - 这样客户端就能得出结论：服务端的发送能力、接收能力是正常的，客户端的发送能力、接受能力是正常的，不过服务端还不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了
  - 这样服务端就能得出结论：客户端的接收、发送，服务端的接收、发送都是正常的

#### 如果是两次握手

如果是两次握手，则会出现下面这种情况

如客户端发出连接请求，但因为连接请求丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络节点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端认为客户端又发出了一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端确认，就建立新的连接了，此时客户端忽略服务端发送的确认，也不发送数据，则服务端一直在等待客户端发送数据，浪费资源

## 半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RECEIVED，此时双方还没有完全建立连接，服务器会把此种状态下的请求连接放入一个队列里，我们把这种队列称之为半连接队列

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中，**如果队列满了就可能出现丢包现象**

### SYN_ACK 重传次数问题

服务器发送完 SYN_ACK 包，如果未收到客户端确认，等待一段时间仍未收到客户端确认包，会进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该链接信息从半连接队列中删除

**注意：一般重传等待的时间不一定相同，一般会是指数增长， 例如时间间隔为：1s，2s，4s，8s，...**

## ISN 是固定的吗?

**当一端为建立连接而发送他的 SYN 时，他为连接选择一个初始序号。ISN 随时间而变化，因此每个具有不同的 ISN**

三次握手的其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道接下来接收数据的时候是如何按序列号组装数据，如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的

## 三次握手过程中可以携带数据吗?

其实第三次握手的时候，是可以携带数据的，但是第一次、第二次握手不可以携带数据

假设第一次握手可以携带数据的话，如果有人恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文携带大量数据的话，因为攻击者根本不理会服务器的接收、发送能力是否正常，然后疯狂重复发送 SYN 报文的话，这会让服务器话费很多时间来接收、内存空间来接收这些报文

也就是，第一次握手不可以携带数据，其中一个简单原因就是让服务器更容易受到攻击了，而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态，对于客户端来说，他已经建立起连接了，并且也知道服务器的接收、发送能力是正常的了，所以携带数据也没啥毛病

## SYN 攻击是什么?

服务端的资源分配是在二次握手时分配的，客户端的资源是在完成三次握手时分配的，所以服务器很容易受到 SYN 洪泛攻击，SYN 攻击就是客户端在短时间内伪造大量不存在的 IP 地址，并向服务器不断的发送 SYN 包，服务器则回复确认包，并等待客户端确认，由于源地址不存在，因为服务器需要不断重发直至超时，这些伪造的 SYN 包将长时间占据半连接队列，导致正常的 SYN 请求因为队列满了而被丢弃，从而引起网络拥塞甚至系统瘫痪， SYN 攻击是一种典型的 DoS/DDoS 攻击

检测 SYN 攻击非常方便，当你在服务器上看到大量的半连接状态，特别是源地址是随机的，基本上可以断定为一次 SYN 攻击，在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```js
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有以下几种：

- 缩短超时(SYN Timeout)时间
- 增加最大半连接数
- 过滤防护网关
- SYN cookies 技术

## 四次挥手

建立一个连接需要三次握手，而终止一个连接需要四次挥手(也有将四次挥手叫做四次握手的)。这由 TCP 的半关闭(half-close)造成的。所谓的半关闭，就是 TCP 提供了连接的一端在结束他的发送后还能接收来自另一端数据的能力

**TCP 的连接的拆除需要四个包，因此被称为四次挥手(Four-way Handshake)，客户端或服务器均可主动发起挥手动作**

在了解四次挥手之前，先来看看每个状态所包含的定义:

> FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

> FIN-WAIT-2 - 从远程TCP等待连接中断请求；

> CLOSE-WAIT - 等待从本地用户发来的连接中断请求；

> CLOSING -等待远程TCP对连接中断的确认；

> LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；

> TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；

> CLOSED - 没有任何连接状态；

刚开始双方都处于 ESTABLISHED 状态，加入是客户端先发起关闭请求。四次会挥手的过程如下:

1. 第一次挥手：客户端发送一个 FIN 报文，报文中指定一个序列号，此时客户端处于 FIN_WAIT1 状态(等待远程 TCP 的连接中断请求，或者是先前的连接中断请求的确认)
   1. 即发出连接释放报文段(FIN=1，序号 seq=u)，并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WATE1(终止等待1)状态，等待服务端的确认
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值+1作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WATE (等待从本地用户发来的连接中断请求)状态

## 详情篇(太深而现在不需要了解)

- [TCP/UDP协议详解...](https://juejin.cn/post/6844903889146216456#heading-16)

## 参考

- [【前端面试必备】DNS/IP/PORT/TCP/UDP/HTTP/HTTPS/三次握手【摘选与JS++网络课】](https://www.bilibili.com/video/BV1bk4y1m7zC)
- [面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)
