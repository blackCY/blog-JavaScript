# 缓存

## 缓存理解

### 缓存定义

浏览器在本地磁盘上将用户之前请求的数据存储起来, 当访问者再次需要改数据的时候无需再次发送请求, 直接从浏览器本地获取数据

### 缓存的好处

1. 减少请求的个数
2. 节省带宽, 避免浪费不必要的网络资源
3. 减轻服务器压力
4. 提高浏览器的加载速度, 提高用户体验

### 缓存分类

1. 强缓存:

   1. 不会向服务器发送请求, 直接从本地缓存中获取数据
   2. 请求资源的状态码为 200 ok(from memory cache 或 memory cache)

   ![img](./百度关于缓存的图.png)
   ![img](./响应头.png)
2. 协商缓存

   1. 向服务器发送请求, 服务器会根据请求头的资源判断是否命中协商缓存
   2. 如果命中(协商成了, 走缓存), 返回 304 状态码通知浏览器从缓存中读取资源
3. 共同点: 都是从浏览器端读取资源
4. 不同点

   1. 强缓存不发送请求给服务器
   2. 协商缓存发送请求给服务器,根据服务器返回的信息决定是否使用缓存

### 缓存使用示意图

![img](https://user-gold-cdn.xitu.io/2020/6/21/172d5928d1b2b6e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 缓存中的 header 参数

> 浏览器默认缓存时间
> Chrome 和 Firefox 对 js/css 之类的文件, 在内存中的缓存时长, 是: (访问时间 - 该文件的最后修改时间) / 10, 例子: 假设 7 点 0 分访问的 5 点 0 分修改的 index.html, 那么缓存时间为 7200 / 10 = 720s, 即页面缓存时间为 720s

#### 强缓存的 header 参数

1. expires
   1. 这是 http1.0 时的规范, 他的值为一个绝对时间的 GMT 格式的时间字符串, 如 `Mon, 10 Jun 2015 21:31:12 GMT`, 如果发送请求的时间在 expires 之前, 那么本地缓存始终有效, 否则就会发送请求到服务器来获取资源
2. cache-control: max-age=number
   1. 这是 http1.1 时出现的 header 信息, 主要是利用该字段的 max-age 值来判断, 它是一个相对值, 是动态的; 资源第一次的请求时间和 Cache-Control 设定的有效期, 计算出一个资源过期时间, 再拿这个过期时间跟当前的请求时间比较, 如果请求时间在过期时间之前, 就能命中缓存, 否则就不行
      1. cache-control 常用的值(做一个简单了解即可)
   2. no-cache: 不使用本地缓存, 需要使用协商缓存, 先与服务器确认返回的响应是否被更改, 如果之前的响应中存在 Etag, 那么请求的时候会与服务器端进行验证, 如果资源没有被更改则使用缓存
   3. no-store: 直接禁止浏览器缓存数据, 每次用户请求该资源, 都会向服务器发送一个请求, 每次都会下载完整的资源
   4. public: 可以被所有的用户缓存, 包括终端用户和 CDN 等中间代理服务器
   5. private: 只能被终端用户的浏览器缓存, 不允许 CDN 等中继缓存服务器对其缓存
   6. 注意: 当 cache-control 与 Expires 共存的时候 cache-control 的优先级高, 例如某些节假日, 某度想换 Logo, 那么就会设置 cache-control, 然后节假日过了之后, 让 cache-control 立即过期, 例如 0, 那么某度的 Logo 又是原来的那个

> 他们是配合 http 缓存的, memory cache 命中最快, 但是它周期较短, base64 的图片, 较小的 js 和 css 能够较大几率被写进内存, 这没有确定的定论, 其他较大的 js, css 和图片等会被直接写进硬盘, 进行缓存

> 存储在磁盘空间的文件通过在浏览器输入 chrome://version

#### 协商缓存

> 协商缓存是由服务器来确定缓存资源是否是可用的, 所以客户端与服务器端要通过某种标识来进行通信, 从而让服务器判断请求资源是否可以缓存访问

Last-Modified(最后一次修改): 服务端生成后给客户端的
If-Modified-Since: 客户端给服务端的, 只是变了一个名字

- Last-Modified/If-Modified-Since: 二者的值都是 GMT 格式的时间字符串

1. 浏览器第一次跟服务器请求一个资源, 服务器在返回这个资源的同时, 在 response 的 header 加上 Last-Modified 的 header 字段, 这个 header 表示这个资源在服务器上的最后修改时间
2. 浏览器再次跟服务器请求这个资源时, 在 request 的 header 上加上 If-Modified-Since 的 header, 这个 header 的值就是上一次请求时返回的 Last-Modified 的值
3. 服务器再次收到资源请求时, 根据浏览器传过来的 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化, 如果没有变化则返回 304 Not Modified 的响应时, 但是不会返回响应资源内容; 如果有变化, 就正常返回资源内容. 当服务器返回 304 Not Modified 的响应时, 更新浏览器缓存有效期, response header 中也不再添加 Last-Modified 的 header, 因为既然资源没有变化, 那么 Last-Modified 也就不会改变, 这是服务器返回 304 时的 response header
4. 浏览器收到 304 的响应后, 就会从缓存中加载资源
5. 如果协商缓存没有命中, 浏览器直接从服务器加载资源时, Last-Modified 的 header 在重新加载的时候会被更新, 下次请求时, If-Modified-Since 会启用上次返回的 Last-Modified 值

##### 协商缓存的 header 参数

- Etag: 服务端生成后给客户端的
- If-Nono-Match: 客户端给服务端的, 只是变了一个名字

1. 这两个值是由服务器生成的每个资源的唯一标识字符串, 只要资源有变化, 这个值就会改变(例如, 高考热度过了, 某度的 logo 就不会从缓存里找图片了, 现在不需要了)(生成规则里没有时间参数)
2. 其判断过程与 Last-Modified/If-Modified-Since 类似

##### 既生 Last-Modified 何生 Etag

1. Http1.1 中的 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题
2. 一些文件也许会周期性的更改, 但是它的内容并不改变, 仅仅改变修改的时间, 所以 Etag 的生成规则里没有考虑时间, 比如服务器坏了, 但是等修好的时候, 里面的文件内容及文件名都是没有改变的, 但是时间变化了, 协商就会失败, 这样就不太好, 这个时候我们并不希望款护短认为这个文件被修改了而重新请求
3. 某些文件修改非常频繁, 比如在秒以下的时间内进行修改(如商品抢购), If-Modified-Since 能检查到的粒度是秒级别的, 这种修改无法判断(或者说 UNIX 记录, MTIME 只能精确到秒)
4. 某些服务器不能精确的得到文件的最后修改时间

### 小结

- 利用 Etag 能够更加准确的控制缓存, 因为 Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符
- Last-Modified 与 Etag 是可以一起使用的, 服务器会优先验证 Etag, 一直的情况下, 才会继续对比 Last-Modified, 最后才决定是否返回 304
- 类似于 expires 和 cache-control, etag / if-none-match 的优先级要比 last-modified / if-modified-since 高

> 如果什么缓存策略都没有设置, 那么浏览器会采用一个启发式的算法, 通常会读取 Response Header 中的 date 头, 减去 last-modified 值得 10% 作为缓存时间

整体流程图:

![img](https://user-gold-cdn.xitu.io/2020/3/25/17110349d0903972?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 强缓存如何重新加载新的资源

- 通过更新页面中引用的资源路径, 让浏览器主动放弃加载缓存去加载新的资源(欺骗浏览器)
- 示例: [https://www.baidu.com/s?t=7aec0h3KB3Ba8lAbuyPg0AC0eDa59IvtDSmtMQBc6eW](https://www.baidu.com/s?t=7aec0h3KB3Ba8lAbuyPg0AC0eDa59IvtDSmtMQBc6eW)
- 例如 WebStorem 里在浏览器上打开 html 的时候, query 就有值
- 好处: 每次文件改变后 query 的值就会发生修改, 当 query 值不同的时候也就是页面引用的资源路径不同, 此时浏览器会主动加载新的资源

### 应用场景

#### 频繁变动的资源

1. 完全不缓存: cache-control: no-store
2. 协商缓存: cache-control: no-cache, 使浏览器每次请求都会走服务器, 然后配合 Etag 或者 last-modified 来验证资源是否有效, 这样对比完全不缓存来说, 虽然无法减少 HTTP 请求到达服务器的次数, 但是可以显著减少响应数据的大小

#### 文件

1. HTML 文件不舍缓存
2. CSS, JS 以及图片等文件资源, 可以设置一个较长的缓存有效期, 比如一年, cache-control: max-age=31536000, 只有当 HTML 文件引入的文件名发生变化时, 才会去下载最新的资源文件, 否则就一直使用缓存

## from memory cache 与 from disk cache 详解

在 chrome 浏览器中的控制台 Network 中 size 栏通常会有三种状态

1. from memory cache
2. from disk cache
3. 资源本身的大小(如: 1.5k)

那么问题来了

1. 三种区别在哪里
2. 浏览器采取不同措施的原则是什么
3. 其他浏览器的策略

下面分别讲述以上三个问题

1.三种区别在哪

from memory cache: 字面理解是从内存中, 其实也是字面的含义, 这个资源是直接从内存中拿到的, 不会请求服务器一般已经加载过该资源且缓存在了内存当中, 当关闭该页面时, 此资源就被内存释放掉了, 再次重新打开相同页面时不会出现 from memory cache 的情况

from disk cache: 同上类似, 此资源是从磁盘当中取出的, 也是在已经在之前的某个时间加载过该资源, 不会请求服务器但是此资源不会随着该页面的关闭而释放掉, 因为是存在硬盘当中的, 下次打开仍会 from disk cache

资源本身大小数值: 当 http 状态为 200 是实实在在从浏览器获取的资源, 当 http 状态为 304 时该数字是与服务端通信报文的大小, 并不是该资源本身的大小, 该资源是从本地获取的

2.chrome 采取措施的准则

什么时候是 from memory cache 什么时候是 from disk cache 呢？

即哪些资源会放在内存当中, 哪些资源浏览器会放在磁盘上呢, 结果如下下表所示


| 状态 | 类型 | 说明 |
| :- | :- | :- |
| 200 | form memory cache | 不请求网络资源, 资源在内存当中, 一般脚本、字体、图片会存在内存当中 |
| 200 | form disk ceche | 不请求网络资源, 在磁盘当中, 一般非脚本会存在内存当中, 如 css 等 |
| 200 | 资源大小数值 | 从服务器下载最新资源 |
| 304 | 报文大小 | 请求服务端发现资源没有更新, 使用本地资源 |

以上是 chrome 在请求资源是最常见的两种 http 状态码
由此可见样式表一般在磁盘中, 不会缓存到内存中去, 因为 css 样式加载一次即可渲染出网页; 但是脚本却可能随时会执行, 如果脚本在磁盘当中, 在执行该脚本需要从磁盘中取到内存当中来, 这样的 IO 开销是比较大的, 有可能会导致浏览器失去响应

3.不同浏览器策略是否一致

以上的数据及统计都是在 chrome 浏览器下进行的, 在 Firefox 下并没有 from memory cache 以及 from disk cache 的状态展现
相同的资源在 chrome 下是 from disk/memory cache, 但是 Firefox 统统是 304 状态码, 即 Firefox 下会缓存资源, 但是每次都会请求服务器对比当前缓存是否更改, chrome 不请求服务器, 直接拿过来用, 这也是为啥 chrome 比较快的原因之一吧, 当然以上是粗略的研究 chrome 资源的获取策略, 至于 chrome 如何保证资源的更新, 即什么时候 200, 什么时候 304 还需要更深入的研究
