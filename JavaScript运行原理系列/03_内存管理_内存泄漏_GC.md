# 内存管理, 内存泄漏, GC

## 概述

像 C 这样的编程语言, 具有低级内存管理原语, 如 malloc()和 free()。开发人员使用这些原语显式地对操作系统的内存进行分配和释放

而 JavaScript 在创建对象(对象, 字符串等)时会为他们分配内存, 不再使用对时会"自动"释放内存, 这个过程称为垃圾收集, 这种看"自动"似释放资源的特性是造成混乱的根源, 因为这给 JavaScript(和其他高级语言)开发人员带来一种错觉, 以为他们可以不关心内存管理的错误印象, 这想一个想法上的错误

即使在使用高级语言时, 开发人员也应该了解内存管理(或至少懂得一些基础知识). 有时候, 自动内存管理存在一些问题(eg: 垃圾收集器中的 bug 货实现限制等), 开发人员必须理解这些问题, 以便正确地处理他们(或找到一个适当的解决方案, 以最小代价来维护代码)

## 内存的生命周期

无论使用哪种编程语言, 内存的生命周期都是一样的

![img](https://segmentfault.com/img/bVbk8st/view?w=954&h=384)

这里简单介绍一下内存生命周期中的每一个阶段

- 分配内存
  内存是由操作系统分配的, 他允许您的程序使用它, 在低级语言(eg: C 语言中), 这是一个开发人员需要自己处理的显式执行的操作. 然而, 在高级语言中, 系统会为你分配内存
- 使用内存
  这是程序实际使用之前分配的内存, **在代码中使用分配的变量时, 就会发生读写操作**
- 释放内存
  释放所有不再使用的内存, 使之成为自由内存, 并可以被重利用, 与分配内存操作一样, 这一操作再低级语言中也是需要显式地执行

## 内存是什么

再介绍 JavaScript 中的内存之前, 我们将简要讨论内存是什么以及它是如何工作的

- **硬件层面上, 计算机内存是由大量的触发器缓存的, 每个触发器包含几个晶体管, 能够存储一位, 单个触发器都可以通过唯一标识符寻址, 因此我们可以读取和覆盖他们, 因此, 从概念上讲, 可以把整个计算机内存看作是一个可以读写的巨大数组**

作为人类, 我们并不擅长用比特来思考和计算, 所以我们把他们组织成更大的组, 这些组一起可以用来表示数字. 8 位称为 1 字节, 除了字节, 还有字(有时是 16 位, 有时是 32 位)

### 很多东西都存储在内存中

- 程序使用的所有变量和其他数据
- 程序的代码, 包括操作系统的代码

编译器和操作系统一起为你处理大部分内存管理, 但你还是需要了解一下底层的情况, 对内在管理概念会有更深入的了解

在编译代码时, 编译器可以检查基本数据类型, 并提前计算他们需要多少内存, 然后将所需的大小分配给调用堆栈空间中的程序, 分配这些变量的空间称为堆栈空间. 因为当调用函数时, 他们的内存将被添加到现有内存之上, 当他们终止时, 他们按照后进先出(LIFO)顺序被移除, 如下图

![img](https://segmentfault.com/img/bVbk8uA/view?w=1456&h=450)

编译器能够立即知道所需的内存: `4 + 44 + 8 = 28` 字节

> 这段代码展示了整型和双精度浮点型变量所占内存的大小. 但是大约 20 年前, 整型变量通常占 2 个字节, 而双精度浮点型变量占 4 个字节, 你的代码不应该依赖于当前基本数据类型的大小

编译器将插入与操作系统交互的代码, 并申请存储变量所需的堆栈字节数

在上面的例子中, 编译器知道每个变量的确切内存地址. 事实上, 每当我们写入变量 n 时, 他就会在内部被转换成类似"内存地址 4127963"这样的信息

注意, 如果我们尝试访问 x[4], 将访问与 m 关联的数据, 这是因为访问数组中一个不存在的元素(他比数组中最后一个实际分配的元素 x[3]多 4 字节). 可能最终读取(或覆盖)一些 m 位, 这肯定会对程序的其余部分产生不可预知的结果

![img](https://segmentfault.com/img/bVXQ4m/view?w=800&h=275)

当函数调用其他函数时, 每个函数在调用堆栈时获得自己的块, 他保存所有的局部变量, 但也会有一个程序计数器来记住他在执行过程中的位置, 当函数完成时, 他的内存块将再次用于其他地方

## 动态分配

不幸的是, 当编译时不知道一个变量需要多少内存时, 事情就有点复杂了, 假设我们想做如下的操作:

![img](https://segmentfault.com/img/bVbk8v2?w=1446&h=450)

在编译时, 编译器不知道数组需要多少内存, 因为这是由用户提供的值决定的

因此, 他不能位堆栈上的变量分配空间, 相反, 我们的程序需要在运行时显式地向操作系统申请适当的空间, 这个内存是从堆空间分配的, 静态内存分配和动态内存分配的区别如下表所示:


| 静态内存分配 | 动态内存分配 |
| :-: | :-: |
| 大小必须在编译时知道 | 大小不需要再编译时知道 |
| 在编译时执行 | 在运行时执行 |
| 分配给堆栈 | 分配给堆 |
| FILO(后进先出) | 没有特定的分配顺序 |

要完全理解动态内存分配时如何工作的, 需要在指针上花费更多的时间, 这可能与本文的主题由太多的偏离
, 这里就不太详细介绍指针的相关知识了

## 在 JavaScript 中分配内存

现在将解释第一步: 如何在 JavaScript 中分配内存
JavaScript 为让开发人员免于手动处理内存分配的责任----JavaScript 自己进行内存分配同时声明值

![img](https://segmentfault.com/img/bVbk8wM/view?w=1456&h=954)

某些函数调用也会导致对象的内存分配

![img](https://segmentfault.com/img/bVbk8wO/view?w=1424&h=414)

方法可以分配新的值或对象

![img](https://segmentfault.com/img/bVbk8w7/view?w=1568&h=594)

## 在 JavaScript 中使用内存

在 JavaScript 中使用分配的内存意味着在其中读写, 这可以通过读取或写入变量或对象属性的值, 或者将参数传递给函数来实现

## 当内存不再需要时进行释放

大多数的内存管理问题都出现在这个阶段

这里最困难的地方是确定何时不再需要分配的内存, 他通常要求开发人员确定程序中哪些地方不再需要内存并释放它

不幸的是, 这个过程只是进行粗略估计, 因为很难知道某块内存是否真的需要(不能通过算法来解决)

- **大多数垃圾收集器通过手机不再被访问的内存来工作, 例如, 指向他的所有变量都超出了作用域, 但是, 这是可以收集的内存空间集合的一个不足估计值, 因为在内存位置的任何一点上, 仍然有可能有一个变量在作用域中指向它, 但是它将永远不会被再次访问**

## 垃圾收集

由于无法确定某些内存是否真的有用, 因此, 垃圾收集器想了一个办法来解决这个问题, 本节将解释理解主要垃圾收集算法及其局限性

### 内存引用

- **垃圾收集算法主要依赖是引用**

在内存管理上下文中, 如果对象具有对另一个对象的访问权(可以是隐式的, 也可以是显式的), 则称对象引用另一个对象。例如, **JavaScript 对象具有对其原型(隐式引用)和属性值(显式引用)的引用**

- **垃圾收集的过程不是实时的, 因为其本身的开销较大, 所以垃圾收集器会按照固定的时间间隔周期性的执行**

在此上下文中, "对象"的概念被扩展到比常规 JavaScript 对象更广泛的范围, 并且还包含函数范围(或全局词法作用域)

> 词法作用域定义了如何在嵌套函数中解析变量名:即使父函数已经返回, 内部函数也包含父函数的作用

### 引用计数垃圾收集算法

这是最简单的垃圾收集算法, 如果没有指向对象的引用, 则认为该对象是"垃圾可回收的", 如下代码

![img](https://segmentfault.com/img/bVbk8AD/view?w=1612&h=954)

> 引用计数的含义时跟踪记录每个值被引用的次数, 当声明了一个变量并将一个引用类型的值赋给该变量时, 则这个值得引用次数就是 1, 如果同一个值又被赋给另外一个变量, 则该值的引用次数+1, 相反, 如果包含对这个值引用的变量又取得了另外一个值, 则这个值得引用次数-1, 当这个值得引用次数变成 0 时, 则说明这个值已经变为了不可访问的一个值, 因而就可以将其占用的内存回收回来, 这样, 当垃圾收集器下次再运行时, 他就会释放那些引用次数为 0 的值所占用的内存

```javascript
function test() {
  var a = {}; //a的引用次数为0
  var b = a; //a的引用次数加1, 为1
  var c = a; //a的引用次数再加1, 为2
  var b = {}; //a的引用次数减1, 为1
}
```

#### 循环会产生问题

当涉及到循环时,会有一个限制。在下面的示例中,创建了两个对象,两个对象互相引用,从而创建了一个循环。在函数调用之后将超出作用域,因此它们实际上是无用的,可以被释放。然而,引用计数算法认为,由于每个对象至少被引用一次,所以它们都不能被垃圾收集

![img](https://segmentfault.com/img/bVbk8AK/view?w=1474&h=630)

![img](https://segmentfault.com/img/bVYaIe/view?w=386&h=209)

循环引用的情况再例如:

```javascript
var element = document.getElementById("element");
var myObject = new Object();
element.o = myObject;
myObject.e = element;
```

这个例子在一个 DOM 元素与一个原生 js 对象之间创建了循环引用, 其中, 变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject, 由于存在这个循环引用, 即使例子中的 DOM 元素从页面中移除, 他也永远不会被回收

看上面的例子, 有同学回觉得太弱了, 谁会做这样无聊的事情, 其实我们是不是就在做

```javascript
window.onload = function outerFunction() {
  var obj = document.getElementById("element");
  obj.onclick = function innerFunction() {};
};
```

这段代码看起来没什么问题, 但是 obj 引用了 `document.getElementById("element")` 而 `document.getElementById("element")` 的 `onclick` 会引用外部环境中的变量, 自然也包括 obj, 是不是很隐蔽啊!

#### 解决办法

最简单的方式就是手动解除循环引用, 比如刚才的函数可以这样:

```javascript
myObject.e = null;
element.o = null;
```

```javascript
window.onload = function outerFunction() {
  var obj = document.getElementById("element");
  obj.onclick = function innerFunction() {};
  obj = null;
};
```

将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时, 就会删除这些值并回收它们占用的内存。

- **要注意的是, IE9+并不存在循环引用导致 Dom 内存泄露问题, 可能是微软做了优化, 或者 Dom 的回收方式已经改变**

#### 引用计数缺点

- 无法回收循环引用的对象
- 资源开销大, 耗时(引用计数需要监控维护引用数值的变化, 对象越多, 需要维护的数值也就越多, 相比其他 GC 算法更为耗时)

### 标记-清除(Mark-and-sweep)算法(simple GC)

该算法能够判断出某个对象是否可以访问, 从而知道该对象是否有用, 该算法由以下步骤组成:

1. 垃圾收集器构建一个 "根" 列表, 用于保存引用的全局变量, 在 JavaScript 中, "window" 对象是一个可作为根节点的全局变量
2. 然后, 算法检查所有的根及其子节点, 并将它们标记为活动的(这意味着它们不是垃圾). 任何根不能到达的地方都将被标记为垃圾
3. 最后, 垃圾收集器释放所有未标记为活动的内存块, 并将该内存返回给操作系统

![img](https://segmentfault.com/img/bVXQ4n/view?w=800&h=423)

这个算法比上一个算法要好, 因为 "一个对象没有被引用", 过去几年在 JavaScript 垃圾收集(分代/增量/并发/并行垃圾收集)领域所做的所有改进都是对该算法(标记-清除)的实现改进, 而不是对垃圾收集算法本身的改进, 也不是他决定对象是否可访问的目标

[在这篇文章中](https://en.wikipedia.org/wiki/Tracing_garbage_collection), 你可以更详细地阅读有关跟垃圾收集的详细信息, 同时还包括了**标记-清除算法**及其优化

#### 什么时候触发

- **当程序运行期间, 若可以使用的内存耗尽时, GC 线程就会将程序暂停开始工作, 先将依旧存活的对象标记一遍, 再讲堆中没有被标记的对象全部清除, 最后让程序恢复运行**

#### 循环不再是问题

在上面的第一个例子中, 在函数调用返回后, 这两个对象不再被从全局对象中可访问的对象引用, 因此, 垃圾收集器将发现他们不可访问

![img](https://segmentfault.com/img/bVYaId/view?w=800&h=600)

- **尽管对象之间存在引用, 但他们对于根节点来说是不可达到的**

#### 缺点

- 空间碎片化: 标记清除回收的内存空间, 在地址上是不连续的, 分散在各个角落, 不能让空间最大化的使用
- 由于不连续, GC 会将回收的内存单元放到一个空闲内存列表中, 对这个列表的维护也是一种开销
- 不会立即回收垃圾对象, 工作时程序是暂停的

### 垃圾收集器的反直观行为

尽管垃圾收集器很方便, 但他们有一套自己的折衷方案, 其中之一就是非决定论, 换句话说, GC(垃圾回收 Garbage Collecation) 是不可预测的, 你无法真正判断何时进行垃圾收集. 这意味着在某些情况下, 程序会使用更多的内存, 这实际上是必需的, 在对速度特别敏感的应用程序中, 可能会很明显的感受到短时间的停顿, 如果没有分配内存, 则大多数 GC 将处于空闲状态, 看看以下场景:

1. 分配一组相当大的内在
2. 这些元素中的大多数(或全部)被标记为不可访问(假设引用指向一个不再需要的缓存)
3. 不再进一步的分配

在这些场景中, 大多数 GC 将不再继续收集, 换句话说, 即使有不可访问的引用可供收集, 收集器也不会声明这些引用, 这些并不是严格意义上的泄漏, 但仍然会导致比通常更高的内存使用

### 内存泄漏是什么

程序的运行需要内存, 只要程序提出要求, 操作系统或者运行时(runtime)就必须供给内存
对于持续运行的服务进程(daemon), 必须及时释放不再用到的内存, 否则, 内存占用越来越高, 轻则影响系统性能, 重则导致进程崩溃

- **从本质上说, 内存泄漏可以定义为: 不再被应用程序所需要的内存, 处于某种原因, 他不会返回到操作系统或空闲池中**

编程语言支持不同的内存管理方式, 然而, 是否使用某一块内存实际上是一个无法确定的问题, 换句话说, 只有开发人员才能明确一块内存是否可以返回到操作系统
某些编程语言为开发人员提供了帮助, 另一些则期望开发人员能清楚地了解内存何时不再被使用, 维基百科上有一些有关[人工](https://en.wikipedia.org/wiki/Manual_memory_management)和[自动内存管理](https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29)的很不错的文章

#### 内存泄漏的识别方法

经验法则是: 如果连续五次 GC 后, 内存占用一次比一次大, 就有内存泄漏, 这就要求实时查看内存的占用情况

在 Chrome 浏览器中, 我们可以这样查看内存占用情况 1.打开开发者工具, 选择 Performance 面板 2.在顶部勾选 Memory 3.点击左上角的 record 按钮 4.在页面上进行各种操作, 模拟用户的使用情况 5.一段时间后, 点击对话框的 stop 按钮, 面板上就会显示这段时间的内存占用情况

来看一张效果图:

![Snipaste_2020-09-02_11-38-10](https://user-images.githubusercontent.com/45334593/91929497-1a518b00-ed11-11ea-9608-a082002d8b2d.png)

我们有两种方式来判定当前是否有内存泄漏:

1.多次快照后, 比较每次快照中内存的占用情况, 如果呈上升趋势, 那么可以认为存在内存泄漏

2.某次快照后, 看当前内存占用的趋势图, 如果走势不平稳, 呈上升趋势, 那么可以认为存在内存泄漏

- **在服务器环境中使用 Node 提供的 process.memoryUsage 方法查看内存情况**

```javascript
console.log(process.memoryUsage());
// {
//   rss: 27709440,
//   heapTotal: 5685248,
//   heapUsed: 3449392,
//   external: 8772
// }
```

process.memoryUsage 返回一个对象, 包含了 Node 进程的内存占用信息。

该对象包含四个字段, 单位是字节, 含义如下:

rss(resident set size): 所有内存占用, 包括指令区和堆栈。
heapTotal："堆"占用的内存, 包括用到的和没用到的。
heapUsed：用到的堆的部分。
external： V8 引擎内部的 C++ 对象占用的内存。
判断内存泄漏, 以 heapUsed 字段为准。

### 四种常见的内存泄漏

#### 全局变量

JavaScript 以一种有趣的方式处理未声明的变量: 对于未声明的变量,会在全局范围中创建一个新的变量来对其进行引用。在浏览器中, 全局对象是 window。例如:

```javascript
function foo(arg) {
  bar = "some text";
}
```

等价于:

```javascript
function foo(arg) {
  window.bar = "some text";
}
```

如果 bar 在 foo 函数的作用域内对一个变量进行引用,却忘记使用 var 来声明它,那么将创建一个意想不到的全局变量。在这个例子中,遗漏一个简单的字符串不会造成太大的危害,但这肯定会很糟

创建一个意料之外的全局变量的另一种方法是使用 this:

```javascript
function foo() {
  this.var1 = "potential accidental global";
}
// Foo自己调用, 它指向全局对象(window), 而不是未定义。
foo();
```

> 可以在 JavaScript 文件的开头通过添加"use strict"来避免这一切, 它将开启一个更严格的 JavaScript 解析模式, 以防止意外创建全局变量

- **尽管我们讨论的是未知的全局变量,但仍然有很多代码充斥着显式的全局变量。根据定义,这些是不可收集的(除非被指定为空或重新分配)。用于临时存储和处理大量信息的全局变量特别令人担忧。如果你必须使用一个全局变量来存储大量数据,那么请确保将其指定为 null,或者在完成后将其重新赋值**

#### 被遗忘的定时器和回调

以 setInterval 为例, 因为它在 JavaScript 中经常使用

```javascript
var serverData = loadData();
setInterval(function () {
  var renderer = document.getElementById("renderer");
  if (renderer) {
    renderer.innerHTML = JSON.stringify(serverData);
  }
}, 5000); //每五秒会执行一次
```

上面的代码片段演示了使用定时器时引用不再需要的节点或数据

renderer 表示的对象可能会在未来的某个时间点被删除,从而导致内部处理程序中的一整块代码都变得不再需要。但是,由于定时器仍然是活动的,所以,处理程序不能被收集,并且其依赖项也无法被收集。这意味着,存储着大量数据的 serverData 也不能被收集

- **在使用观察者时, 您需要确保在使用完它们之后进行显式调用来删除它们(要么不再需要观察者, 要么对象将变得不可访问)**
- **作为开发者时, 需要确保在完成它们之后进行显式删除它们(或者对象将无法访问)**
- **在过去, 一些浏览器无法处理这些情况(很好的 IE6)。幸运的是, 现在大多数现代浏览器会为帮你完成这项工作:一旦观察到的对象变得不可访问, 即使忘记删除侦听器, 它们也会自动收集观察者处理程序。然而,我们还是应该在对象被处理之前显式地删除这些观察者**。例如:

![img](https://segmentfault.com/img/bVbk8Gk/view?w=1578&h=774)

如今, 现在的浏览器（包括 IE 和 Edge）使用现代的垃圾回收算法, 可以立即发现并处理这些循环引用。换句话说, 在一个节点删除之前也不是必须要调用 removeEventListener

一些框架或库,比如 JQuery,会在处置节点之前自动删除监听器(在使用它们特定的 API 的时候)。这是由库内部的机制实现的,能够确保不发生内存泄漏,即使在有问题的浏览器下运行也能这样,比如...IE 6。

#### 闭包

闭包是 javascript 开发的一个关键方面, 一个内部函数使用了外部（封闭）函数的变量。由于 JavaScript 运行的细节, 它可能以下面的方式造成内存泄漏:

![img](https://segmentfault.com/img/bVbk8GG/view?w=1448&h=882)

这段代码做了一件事:每次调用 replaceThing 的时候,theThing 都会得到一个包含一个大数组和一个新闭包(someMethod)的新对象。同时,变量 unused 指向一个引用了`originalThing 的闭包。

是不是有点困惑了? 重要的是,一旦具有相同父作用域的多个闭包的作用域被创建,则这个作用域就可以被共享。

在这种情况下,为闭包 someMethod 而创建的作用域可以被 unused 共享的。unused 内部存在一个对 originalThing 的引用。即使 unused 从未使用过,someMethod 也可以在 replaceThing 的作用域之外(例如在全局范围内)通过 theThing 来被调用。

由于 someMethod 共享了 unused 闭包的作用域,那么 unused 引用包含的 originalThing 会迫使它保持活动状态(两个闭包之间的整个共享作用域)。这阻止了它被收集。

当这段代码重复运行时,可以观察到内存使用在稳定增长,当 GC 运行后,内存使用也不会变小。从本质上说,在运行过程中创建了一个闭包链表(它的根是以变量 theThing 的形式存在),并且每个闭包的作用域都间接引用了一个大数组,这造成了相当大的内存泄漏

#### 脱离 DOM 的引用

有时,将 DOM 节点存储在数据结构中可能会很有用。假设你希望快速地更新表中的几行内容,那么你可以在一个字典或数组中保存每个 DOM 行的引用。这样,同一个 DOM 元素就存在两个引用:一个在 DOM 树中,另一个则在字典中。如果在将来的某个时候你决定删除这些行,那么你需要将这两个引用都设置为不可访问

![img](https://segmentfault.com/img/bVbk8HE/view?w=1568&h=774)

在引用 DOM 树中的内部节点或叶节点时, 还需要考虑另外一个问题。如果在代码中保留对表单元格的引用(`<td>`标记), 并决定从 DOM 中删除表, 同时保留对该特定单元格的引用, 那么可能会出现内存泄漏

你可能认为垃圾收集器将释放除该单元格之外的所有内容。然而, 事实并非如此, 由于单元格是表的一个子节点, 而子节点保存对父节点的引用, 所以对表单元格的这个引用将使整个表保持在内存中, 所以在移除有被引用的节点时候要移除其子节点

#### 如何避免内存泄漏

- **记住一个原则: 不用的东西, 及时归还**

1. 减少不必要的全局变量, 使用严格模式避免意外创建全局变量
2. 在你使用完数据以后, 及时解除引用(闭包中的变量, dom 引用, 清除定时器)
3. 组织好你的逻辑, 避免死循环等造成的浏览器卡顿和崩溃的问题

## Garbarge Collection

### 常见 GC 算法

- 引用计数
- 标记清除(simple GC)
- 标记整理(V8)
- 分代回收(V8)

### GC 的缺陷

和其他语言一样, JavaScript 的 GC 策略也无法避免一个问题: GC 时, 停止响应其他操作, 这是为了安全考虑, 而 JavaScript 的 GC 在 100ms 甚至以上, 对一般的应用还好, 但对于 js 游戏, 动画对连贯性要求较高的应用, 就麻烦了, 这就是新引擎需要优化的点: **避免 GC 造成的长时间停止响应**

### GC 优化策略

David 大叔主要介绍了 2 个优化方案, 而这也是最主要的 2 个优化方案了

- 分代回收(Generation GC)

这个和 Java 回收策略思想是一致的。目的是通过区分"临时"与"持久"对象；多回收"临时对象"区(young generation), 少回收"持久对象"区(tenured generation), 减少每次需遍历的对象, 从而减少每次 GC 的耗时。如图:

![Snipaste_2020-09-02_11-41-33](https://user-images.githubusercontent.com/45334593/91929584-466d0c00-ed11-11ea-8b4a-330c5e5182a7.png)

这里需要补充的是: 对于 tenured generation 对象, 有额外的开销：把它从 young generation 迁移到 tenured generation, 另外, 如果被引用了, 那引用的指向也需要修改。

- 增量 GC

这个方案的思想很简单, 就是"每次处理一点, 下次再处理一点, 如此类推"。如图:

![Snipaste_2020-09-02_11-42-42](https://user-images.githubusercontent.com/45334593/91929646-6d2b4280-ed11-11ea-9ed1-f72d458c5cd3.png)

这种方案, 虽然耗时短, 但中断较多, 带来了上下文切换频繁的问题。

因为每种方案都其适用场景和缺点, 因此在实际应用中, 会根据实际情况选择方案。

比如：低 (对象/s) 比率时, 中断执行 GC 的频率, simple GC 更低些, 如果大量对象都是长期"存活", 则分代处理优势也不大

其他的 GC 算法以及一些介绍可参考这篇[文章](https://blog.csdn.net/u012961419/article/details/108237610)

## 参考文章

- [3.JavaScript 如何工作:内存管理+如何处理 4 个常见的内存泄漏](https://github.com/qq449245884/xiaozhi/issues/3)
- [中高级前端必须了解的 JS 中的内存管理(推荐)](https://www.jb51.net/article/164566.htm)
- [跟我学习 javascript 的垃圾回收机制与内存管理](https://www.jb51.net/article/75292.htm)
- [JavaScript 性能优化、内存管理、垃圾回收](https://blog.csdn.net/u012961419/article/details/108237610)
