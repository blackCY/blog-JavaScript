#### 阻塞与非阻塞

阻塞这个词来自操作系统的线程/进程的状态模型中, 如下图:

![img](https://img-blog.csdn.net/20161223093414586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzU1MTIyNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**一个线程/进程经历的 5 个状态: 创建, 就绪, 运行, 阻塞, 终止**

阻塞状态: 当线程中调用某个函数, 需要 I/O 请求, 或者暂时得不到竞争资源的, 操作系统会把该线程阻塞起来, 即挂起, 避免浪费 CPU 资源, 一直处于等待消息通知, 等到得到了资源, 再变成就绪状态, 等待 CPU 调度运行, 这期间不能够执行其他业务

阻塞调用是指调用结果返回之前, 调用者会进入阻塞状态等待, 只有在得到结果之后才会返回
非阻塞调用是指在不能立即得到结果之前, 该函数不会阻塞当前线程, 而会立刻返回

阻塞调用: 比如 socket 的 recv(), 调用这个函数的线程如果没有数据返回, 他会一直阻塞着, 也就是 recv() 后面的代码都不会执行了, 程序就停在 recv() 这里等待, 所以一般把 recv() 放在单独的线程里调用
非阻塞调用: 比如非阻塞 socket 的 send(), 调用这个函数, 他只是把待发送的数据复制到 TCP 输出缓冲区中, 就立刻返回了, 线程并不会阻塞, 数据有没有发出去 send() 是不知道的, 不会等待他发出去才返回的

如果线程始终阻塞着, 永远得不到资源, 于是就发生了死锁
比如 A 线程要 X, Y 资源才能继续运行, B 线程也要 X, Y 资源才能运行, 但 X, Y 同时只能给一个线程用(即互斥条件), 用的时候其他线程又不能抢夺

A 有 X, 等待 Y
B 有 Y, 等待 X

于是 A, B 发生了循环等待, 造成死锁, 给用户的感觉就是程序卡着不动了

**阻塞和挂起: 阻塞时被动的, 比如抢不到资源, 挂起是主动的, 线程自己调用 suspend() 把自己退出运行状态了, 某些时候调用 resume() 有恢复运行**

#### 同步与异步

- 同步: 所为同步就是一个任务的完成需要依赖另外一个任务时, 只有等待被依赖的任务完成后, 依赖的任务才能算完成, 这是一种可靠的任务序列, 要么成功都成功, 要么士兵都失败, 两个任务的状态可以保持一致
- 异步: 异步是不需要等待被依赖的任务完成, 只是通知被依赖的任务要完成什么工作, 依赖的任务也立即执行, 只要自己完成了整个任务就算完成了, 至于被依赖的任务最终是否真正完成, 依赖它的任务无法确定, 所以他是不可靠的任务序列
- 消息通知: 异步的概念和同步相对, 当一个同步调用发出后, 调用者要一直等待返回消息(结果)通知后, 才能进行后续的执行, 当一个异步过程调用发出后, 调用者不能立刻得到返回消息(结果), 实际处理这个调用的部件在完成后, 通过状态和通知以及回调来通知调用者

#### 同步与异步/阻塞与非阻塞 结合

阻塞与非阻塞, 和同步异步无关, 可以阻塞等待同步执行过程完成, 也可以阻塞等待异步执行过程完成, 阻塞与非阻塞/同步与异步是可以相互结合的

- 同步阻塞
  调用者发起 I/O 操作请求, 等待 I/O 操作完成在返回, I/O 操作的过程需要等待, 操作执行完成后返回结果
- 同步非阻塞
  调用者发起 I/O 操作请求, 询问 I/O 操作的状态, 如果未完成, 则立即返回, 如果完成, 则返回结果, I/O 操作的过程需要等待执行完成才返回结果
- 异步阻塞
  调用者发起 I/O 操作请求, 等待 I/O 操作完成再返回, I/O 操作的过程不需要等待, 操作完成后通过通知或回调获得结果

**首先需要明确: 异步操作是可以被阻塞住的, 只不过他不是在处理消息时阻塞, 而是在等待消息通知时被阻塞**

- 异步非阻塞
  调用者发起 I/O 操作请求, 询问 I/O 操作的状态, 如果未完成, 则立即返回, 如果完成则返回结果, I/O 操作的过程不需要等待, 操作完成后通过通知或回调获得结果
